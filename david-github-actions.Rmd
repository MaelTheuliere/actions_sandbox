# Github actions

```{r setup2, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE, eval = FALSE)
```

## The standard package check

When we ran `usethis::use_github_actions` we generated a `R-CMD-check.yaml` file in the `.github/workflows` folder. YAML is a configuration file that's meant to be read by both humans and machines. In this case, the YAML file tells GitHub what we want the action to do. Let's dig into the contents of this file to see what's going on:

```
on: [push, pull_request]

name: R-CMD-check

jobs:
  R-CMD-check:
    runs-on: macOS-latest
    steps:
      - uses: actions/checkout@v1
      - uses: r-lib/actions/setup-r@master
      - name: Install dependencies
        run: Rscript -e "install.packages(c('remotes', 'rcmdcheck'))" -e "remotes::install_deps(dependencies = TRUE)"
      - name: Check
        run: Rscript -e "rcmdcheck::rcmdcheck(args = '--no-manual', error_on = 'error')"
```

You can find full documentation about these parameters on [GitHub](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions), but we'll highlight a few key points here:

* The `on` parameter tells GitHub what should trigger this action. In this case, we want to check code whenever it is pushed, or on a pull request. The latter is particularly useful because if we're about to merge code into the master branch, we want it to pass tests!
* The `name` of the action should be something that helps us identify at a glance what the action is doing. This is shown on github.com in the Actions tab of the repository.
* `runs-on` tells GitHub what sort of environment should run the job. These environments are called "runners". GitHub supports Ubuntu, macOS and Windows Server, as well as support for self-hosted runners.
* `uses` allows us to run other actions as part of our action. In this case, we're calling on actions that are defined in other repositories. The first action checks out the contents of our repository, and the next sets up R.
* The remaining steps are the commands we want to run as part of our action, each with a name. Here's we're installing the dependencies of our package, as well as the `rcmdcheck` package we use to check the package in our repository. Finally, we're executing the command that checks the package.

You may also have added a badge to your README file. These badges change appearance automatically based on the outcome of the action. [You can read more on GitHub](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/configuring-a-workflow#adding-a-workflow-status-badge-to-your-repository).

# Testing with a reproducible environment

We can take testing a step further by setting up an environment that mimics the one we used to train out model, and is set up the same way each time. First we need to set up a *lockfile* for our package that tells R exactly what packages --- including the versions --- should be used to reproduce this 

We'll be using the `renv` package, but a word of warning first: this package is still under active development, so this information may quickly become outdated.

Once you've installed `renv`, open the R project containing your package and run `renv::snapshot()`. There will be a prompt for your consent to alter some files in your project and system. This function will automatically determine the dependencies used in your package, as well as what packages (and versions) are installed on your system, and will record this information in a lock file.

When you open your project in the future, RStudio will automatically load the packages that are recorded in the snapshot, down to the version number. If the specific versions aren't available, it will download them and install them from source, or using available binaries. Try restarting your R environment to see this happen. We can trigger this behaviour manually with `renv::restore()`. To learn more about the `renv` package, [read the introductory article](https://rstudio.github.io/renv/articles/renv.html).

Now we need to configure GitHub actions to use the snapshot we've just set up. In the previous action, we used macOS so that we could take advantage of available package binaries for quick installation. I'm going to be using Ubuntu for this to replicate my person Linux environment, and this means that packageres will be installed from source.

Here's the workflow that I'm using. Read through it and see if you can work out what's going on, and then we'll go through the finer details:

```
on: [push, pull_request]

name: R-CMD-check

jobs:
  R-CMD-check:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v1
      - uses: r-lib/actions/setup-r@master
        with:
            r-version: '3.6.1'
      - name: Install libcurl
        run: sudo apt-get install libcurl4-openssl-dev
      - name: Install renv 0.9.2
        run: Rscript -e "install.packages('https://cran.r-project.org/src/contrib/renv_0.9.2.tar.gz', repos = NULL, type = 'source')"
      - name: Install rcmdcheck 1.3.3
        run: Rscript -e "install.packages('https://cran.r-project.org/src/contrib/rcmdcheck_1.3.3.tar.gz', repos = NULL, type = 'source')"
      - name: Check
        run: Rscript -e "renv::restore();rcmdcheck::rcmdcheck(args = '--no-manual', error_on = 'error')"
```

There are a few differences with this workflow:

* I've specified a version of R to install, for better reproducibility.
* I've installing a package for the operating system, `libcurl4-openssl-dev`. Because we're installing R packages from source, we need to be sure that our operating system has all of the tools it needs to compile the source files. This particular package is required to use `curl` within R; this is pretty important, since if you're doing anything involving the internet, there's a good chance you're using `curl` *somewhere*. Your specific package may not need this, but I'm including it here as an example of how to run `apt-get` in GitHub Actions.
* We're installing two packages individually here: `renv` and `rcmdcheck`. We need `renv` to `restore` our lockfile, so we need to specifically install it before we think about package dependencies. Finally, `rcmdcheck` is not (usually) a package dependency, and we need it to check our package. Note that we're manually specifying version numbers here for reproducibility.
* Our final step looks a little different. We're calling `renv::restore()`, which automatically handles all of our package dependencies. Then we run `rcmdcheck` as we did before.

On Ubuntu, packages are installed from source. This is **much** slower; on one of my packages, testing in a reproducible environment on Ubuntu takes 35 minutes, as opposed to 4 minutes. Caching can make life easier, so let's take a look at that now.

